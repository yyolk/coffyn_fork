// Generated by CoffeeScript 1.10.0
(function() {
  var CFN_FUNCS, INDENT, checkForParams, convertArray, convertCondition, convertFunction, convertJson, convertMapping, convertObj, convertOutput, convertParam, convertResource, convertToArgs, convertToCoffin, convertTopLevel, createForwardDeclrations, escapeString, fs, indent, isFunction, paramNames;

  fs = require("fs");

  paramNames = [];

  INDENT = "  ";

  convertToArgs = function(string) {
    return string.replace("[", "").replace("]", "").replace(/\n$/, "");
  };

  CFN_FUNCS = {
    "Fn::Base64": function(obj, level, parentIsObj) {
      return "@Base64(" + (convertJson(obj["Fn::Base64"], level, parentIsObj)) + ")";
    },
    "Fn::FindInMap": function(obj, level, parentIsObj) {
      var string;
      string = convertJson(obj["Fn::FindInMap"], level, parentIsObj);
      return "@FindInMap(" + (convertToArgs(string)) + ")";
    },
    "Fn::GetAtt": function(obj, level, parentIsObj) {
      var string;
      string = convertJson(obj["Fn::GetAtt"], level, parentIsObj);
      return "@GetAtt(" + (convertToArgs(string)) + ")";
    },
    "Fn::GetAZs": function(obj, level, parentIsObj) {
      return "@GetAZs(" + (convertJson(obj["Fn::GetAZs"], level, parentIsObj)) + ")";
    },
    "Fn::Join": function(obj, level, parentIsObj) {
      var join, string;
      join = obj["Fn::Join"];
      string = convertJson(join[1], level, parentIsObj);
      return "@Join(\"" + (escapeString(join[0])) + "\", " + (string.replace(/\n$/, "")) + ")";
    },
    "Ref": function(obj) {
      if (paramNames.indexOf(obj.Ref) > -1) {
        return "@Params." + obj.Ref;
      } else if (obj.Ref === "AWS::Region") {
        return "@Region";
      } else if (obj.Ref === "AWS::StackName") {
        return "@StackName";
      } else {
        return "@Resources." + obj.Ref;
      }
    }
  };

  indent = function(text, times) {
    var front, i, j, ref;
    front = "";
    for (i = j = 0, ref = times; 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {
      front += INDENT;
    }
    return front + text;
  };

  convertArray = function(arr, level, parentIsArray) {
    var addNewline, end, i, j, len, output, val;
    if (level == null) {
      level = 0;
    }
    if (arr.length > 5 || typeof arr[0] === "object") {
      addNewline = true;
    } else {
      addNewline = false;
    }
    output = "[";
    if (addNewline) {
      output += "\n";
    }
    i = arr.length;
    for (j = 0, len = arr.length; j < len; j++) {
      val = arr[j];
      if (addNewline) {
        output += indent((convertJson(val, level + 1, true)) + "\n", level);
      } else {
        if (--i) {
          output += (convertJson(val, level)) + ", ";
        } else {
          output += convertJson(val, level);
        }
      }
    }
    end = "]\n";
    if (parentIsArray) {
      end = "]";
    }
    if (addNewline) {
      end = indent(end, level - 1);
    }
    output += end;
    return output;
  };

  isFunction = function(obj) {
    var fun, j, len, ref;
    ref = Object.keys(CFN_FUNCS);
    for (j = 0, len = ref.length; j < len; j++) {
      fun = ref[j];
      if (obj[fun]) {
        return true;
      }
    }
    return false;
  };

  convertFunction = function(obj, level, parentIsObj) {
    var cfn, fun, output;
    output = null;
    for (cfn in CFN_FUNCS) {
      fun = CFN_FUNCS[cfn];
      if (obj[cfn]) {
        output = fun(obj, level, parentIsObj);
      }
    }
    return output;
  };

  convertObj = function(obj, level, parentIsObj) {
    var key, keyLength, output, val;
    if (level == null) {
      level = 0;
    }
    if (isFunction(obj)) {
      return indent(convertFunction(obj, level, parentIsObj));
    }
    if (parentIsObj) {
      output = "\n";
    } else {
      output = "";
    }
    keyLength = Object.keys(obj).length;
    for (key in obj) {
      val = obj[key];
      if (key.match(/\W/)) {
        key = "\"" + key + "\"";
      }
      output += indent(key + " : " + (convertJson(val, level + 1, true)), level);
      if (--keyLength) {
        output += "\n";
      }
    }
    return output;
  };

  escapeString = function(string) {
    return string.replace("\n", "\\n").replace(/'/g, "\\'").replace(/"/g, '\\"');
  };

  convertJson = function(obj, level, parentIsObj) {
    if (level == null) {
      level = 0;
    }
    if (Array.isArray(obj)) {
      return convertArray(obj, level, parentIsObj);
    } else if (typeof obj === "object") {
      return convertObj(obj, level, parentIsObj);
    } else if (typeof obj === "string") {
      return "\"" + (escapeString(obj)) + "\"";
    } else if (typeof obj === "number") {
      return obj;
    }
  };

  checkForParams = function(obj) {
    if (obj && Object.keys(obj).length) {
      return true;
    } else {
      return false;
    }
  };

  convertParam = function(name, val) {
    var output;
    if (!val.Type) {
      throw new Error("type is required for Param " + name);
    }
    paramNames.push(name);
    output = null;
    if (val.Description) {
      output = "@Param." + val.Type + " \"" + name + "\", \"" + val.Description + "\"";
    } else {
      output = "@Param." + val.Type + " \"" + name + "\"";
    }
    delete val.Type;
    delete val.Description;
    if (checkForParams(val)) {
      output += ",\n";
      output += convertJson(val);
    }
    return output + "\n\n";
  };

  convertMapping = function(name, val) {
    var output;
    output = "@Mapping \"" + name + "\",\n";
    output += convertJson(val);
    return output + "\n\n";
  };

  convertResource = function(name, val) {
    var output;
    if (!val.Type) {
      throw new Error("missing type for resource with " + name);
    }
    output = "@" + (val.Type.replace(/::/g, ".")) + " \"" + name + "\"";
    if (val.Metadata) {
      delete val.Type;
      if (checkForParams(val)) {
        output += ",\n";
        output += convertJson(val);
      }
    } else {
      if (checkForParams(val.Properties)) {
        output += ",\n";
        output += convertJson(val.Properties);
      }
    }
    return output + "\n\n";
  };

  convertOutput = function(name, val) {
    var output;
    if (!val.Value) {
      throw new Error("missing value for output with " + name);
    }
    if (val.Description) {
      output = "@Output \"" + name + "\", \"" + val.Description + "\",\n";
    } else {
      output = "@Output \"" + name + "\",\n";
    }
    output += convertJson(val.Value);
    return output + "\n\n";
  };

  convertCondition = function(name, intrinsicfn) {
    var output;
    if (!intrinsicfn) {
      throw new Error("missing intrinsicfn for condition with " + name);
    }
    output = "@Condition \"" + name + "\",";
    output += convertJson(intrinsicfn);
    return output + "\n\n";
  };

  convertTopLevel = function(params, converter) {
    var name, output, val;
    output = "";
    for (name in params) {
      val = params[name];
      output += converter(name, val);
    }
    return output;
  };

  createForwardDeclrations = function(resources) {
    var output, res, val;
    output = "";
    for (res in resources) {
      val = resources[res];
      output += "@DeclareResource(\"" + res + "\")\n";
    }
    return output;
  };

  convertToCoffin = function(templateObj) {
    var key, output, val;
    output = "";
    output += createForwardDeclrations(templateObj.Resources);
    for (key in templateObj) {
      val = templateObj[key];
      switch (key) {
        case "AWSTemplateFormatVersion":
          break;
        case "Description":
          output += "@Description \"" + val + "\"\n\n";
          break;
        case "Parameters":
          output += convertTopLevel(val, convertParam);
          break;
        case "Mappings":
          output += convertTopLevel(val, convertMapping);
          break;
        case "Resources":
          output += convertTopLevel(val, convertResource);
          break;
        case "Outputs":
          output += convertTopLevel(val, convertOutput);
          break;
        case "Conditions":
          output += convertTopLevel(val, convertCondition);
          break;
        default:
          console.log("don't have key " + key);
      }
    }
    return output;
  };

  module.exports = convertToCoffin;

}).call(this);
