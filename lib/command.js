// Generated by CoffeeScript 1.10.0
(function() {
  var CoffeeScript, buildCfnPath, checkChar, coffinChar, colors, commandHelper, commander, compileCommand, compileTemplate, createStack, crossChar, decompileCfnTemplate, decompileCommand, exec, fs, generateOutputFileName, generateTempFileName, parseTemplate, path, pretty, printCommand, ref, showHelp, spawn, stackCommand, updateOrCreateStack, validateArgs, validateCommand, validateTemplate, writeJsonTemplate,
    slice = [].slice;

  fs = require('fs');

  path = require('path');

  colors = require('colors');

  commander = require('commander');

  CoffeeScript = require('coffee-script');

  ref = require('child_process'), spawn = ref.spawn, exec = ref.exec;

  parseTemplate = require('./parseTemplate');

  commandHelper = require('./commandHelper');

  coffinChar = '\u26B0'.grey;

  checkChar = '\u2713'.green;

  crossChar = '\u2717'.red;

  validateArgs = function() {
    var valid;
    valid = true;
    if (commander.args.length === 0) {
      console.error("You need to specify a coffin template to act on.");
      valid = false;
    }
    if ((commander.validate != null) || (commander.createStack != null) || (commander.updateStack != null)) {
      if (commander.print != null) {
        console.error("I can't run that command if you're just printing to the console.");
        valid = false;
      }
      if (!process.env.AWS_CLOUDFORMATION_HOME && (commander['cfn-home'] == null)) {
        console.error("Either an AWS_CLOUDFORMATION_HOME environment variable or a --cfnHome switch is required.");
        valid = false;
      }
    }
    if (!valid) {
      process.stdout.write(commander.helpInformation());
      return process.exit(0);
    }
  };

  compileTemplate = (function(_this) {
    return function(source, params, callback) {
      var pre;
      pre = "require('../lib/coffin') ->\n";
      return fs.readFile(source, function(err, code) {
        var compiled, i, len, line, ref1, tabbedLines, template, templateString;
        if (err) {
          console.error(source + " not found");
          process.exit(1);
        }
        tabbedLines = [];
        if (params == null) {
          params = [];
        }
        tabbedLines.push("  @ARGV = " + (JSON.stringify(params)));
        ref1 = code.toString().split('\n');
        for (i = 0, len = ref1.length; i < len; i++) {
          line = ref1[i];
          tabbedLines.push('  ' + line);
        }
        tabbedLines.push('  return');
        code = tabbedLines.join('\n');
        code = pre + code;
        compiled = CoffeeScript.compile(code, {
          source: source,
          bare: true
        });
        template = eval(compiled, source);
        templateString = commander.pretty ? JSON.stringify(template, null, 2) : JSON.stringify(template);
        return typeof callback === "function" ? callback(templateString) : void 0;
      });
    };
  })(this);

  decompileCfnTemplate = function(source, callback) {
    return fs.readFile(source, "utf8", function(err, cfnTemp) {
      var decompiled;
      if (err) {
        console.log(source + " not found");
        process.exit(1);
      }
      decompiled = parseTemplate(JSON.parse(cfnTemp));
      return callback(decompiled);
    });
  };

  writeJsonTemplate = function(json, templatePath, callback) {
    var base, write;
    write = function() {
      if (json.length <= 0) {
        json = ' ';
      }
      return fs.writeFile(templatePath, json, function(err) {
        if (err != null) {
          console.error("failed to write to " + templatePath);
          console.error(err.message);
          process.exit(1);
        }
        return typeof callback === "function" ? callback() : void 0;
      });
    };
    base = path.dirname(templatePath);
    return path.exists(base, function(exists) {
      if (exists) {
        return write();
      } else {
        return exec("mkdir -p " + base, write);
      }
    });
  };

  generateTempFileName = function() {
    var dateStamp, e, name, now, rand, tmpDir;
    e = process.env;
    tmpDir = e.TMPDIR || e.TMP || e.TEMP || '/tmp';
    now = new Date();
    dateStamp = now.getYear();
    dateStamp <<= 4;
    dateStamp |= now.getMonth();
    dateStamp <<= 5;
    dateStamp |= now.getDay();
    rand = (Math.random() * 0x100000000 + 1).toString(36);
    name = (dateStamp.toString(36)) + "-" + (process.pid.toString(36)) + "-" + rand + ".template";
    return path.join(tmpDir, name);
  };

  generateOutputFileName = function(source, extension) {
    var base, filename;
    base = commander.output || path.dirname(source);
    filename = path.basename(source, path.extname(source)) + extension;
    return path.join(base, filename);
  };

  buildCfnPath = function() {
    var cfnHome;
    cfnHome = commander['cfn-home'] || process.env.AWS_CLOUDFORMATION_HOME;
    return path.normalize(path.join(cfnHome, 'bin'));
  };

  validateTemplate = (function(_this) {
    return function(templatePath, callback) {
      var errorText, resultText, validateExec;
      validateExec = spawn(path.join(buildCfnPath(), 'cfn-validate-template'), ['--template-file', templatePath]);
      errorText = '';
      resultText = '';
      validateExec.stderr.on('data', function(data) {
        return errorText += data.toString();
      });
      validateExec.stdout.on('data', function(data) {
        return resultText += data.toString();
      });
      return validateExec.on('exit', function(code) {
        if (code === 0) {
          process.stdout.write(checkChar + "\n");
          process.stdout.write(resultText);
        } else {
          process.stdout.write(crossChar + "\n");
          process.stderr.write(errorText);
        }
        return typeof callback === "function" ? callback(code) : void 0;
      });
    };
  })(this);

  updateOrCreateStack = (function(_this) {
    return function(name, templatePath, compiled, callback) {
      var args, resultText, updateErrorText, updateExec;
      args = ['--template-file', templatePath, '--stack-name', name];
      if (commandHelper.doesTemplateReferenceIAM(compiled)) {
        args.push('-c');
        args.push('CAPABILITY_IAM');
      }
      updateExec = spawn((buildCfnPath()) + "/cfn-update-stack", args);
      updateErrorText = '';
      resultText = '';
      updateExec.stderr.on('data', function(data) {
        return updateErrorText += data.toString();
      });
      updateExec.stdout.on('data', function(data) {
        return resultText += data.toString();
      });
      return updateExec.on('exit', function(code) {
        var existsSyncFunc;
        existsSyncFunc = fs.existsSync != null ? fs.existsSync : path.existsSync;
        if (existsSyncFunc((buildCfnPath()) + "/cfn-update-stack")) {
          if (code === 0) {
            process.stdout.write("stack '" + name + "' (updated) " + checkChar + "\n");
            process.stdout.write(resultText);
            if (typeof callback === "function") {
              callback(code);
            }
            return;
          }
          if (updateErrorText.match(/^cfn-update-stack:  Malformed input-No updates are to be performed/) != null) {
            process.stdout.write("stack '" + name + "' (no changes)\n");
            process.stdout.write(resultText);
            if (typeof callback === "function") {
              callback(0);
            }
            return;
          }
          if (updateErrorText.match(/^cfn-update-stack:  Malformed input-Stack with ID\/name/) == null) {
            console.error(updateErrorText);
            if (typeof callback === "function") {
              callback(code);
            }
            return;
          }
        }
        return createStack(name, templatePath, compiled, callback);
      });
    };
  })(this);

  createStack = (function(_this) {
    return function(name, templatePath, compiled, callback) {
      var args, createExec, errorText, resultText;
      args = ['--template-file', templatePath, '--stack-name', name];
      if (commandHelper.doesTemplateReferenceIAM(compiled)) {
        args.push('-c');
        args.push('CAPABILITY_IAM');
      }
      createExec = spawn((buildCfnPath()) + "/cfn-create-stack", args);
      errorText = '';
      resultText = '';
      createExec.stdout.on('data', function(data) {
        return resultText += data.toString();
      });
      createExec.stderr.on('data', function(data) {
        return errorText += data.toString();
      });
      return createExec.on('exit', function(code) {
        if (code !== 0) {
          if (errorText.match(/^cfn-create-stack:  Malformed input-AlreadyExistsException/) != null) {
            process.stderr.write("stack '" + name + "' already exists " + crossChar + "\n");
            return;
          }
          process.stderr.write(errorText);
          return;
        }
        process.stdout.write("stack '" + name + "' (created) " + checkChar + "\n");
        process.stdout.write(resultText);
        return typeof callback === "function" ? callback(code) : void 0;
      });
    };
  })(this);

  pretty = {
    "switch": '-p, --pretty',
    text: 'Add spaces and newlines to the resulting json to make it a little prettier'
  };

  commander.version(require('./coffin').version);

  commander.usage('[options] <coffin template>');

  commander.option('-o, --output [dir]', 'Directory to output compiled file(s) to');

  commander.option('--cfn-home [dir]', 'The home of your AWS Cloudformation tools. Defaults to your AWS_CLOUDFORMATION_HOME environment variable.');

  commander.option(pretty["switch"], pretty.text);

  printCommand = commander.command('print [template]');

  printCommand.description('Print the compiled template.');

  printCommand.action(function() {
    var params, template;
    template = arguments[0], params = 2 <= arguments.length ? slice.call(arguments, 1) : [];
    validateArgs();
    return compileTemplate(template, params, function(compiled) {
      return console.log(compiled);
    });
  });

  validateCommand = commander.command('validate [template]');

  validateCommand.description('Validate the compiled template. Either an AWS_CLOUDFORMATION_HOME environment variable or a --cfn-home switch is required.');

  validateCommand.action(function() {
    var params, template;
    template = arguments[0], params = 2 <= arguments.length ? slice.call(arguments, 1) : [];
    validateArgs();
    return compileTemplate(template, params, function(compiled) {
      var tempFileName;
      process.stdout.write(coffinChar + " " + template + " ");
      tempFileName = generateTempFileName();
      return writeJsonTemplate(compiled, tempFileName, function() {
        return validateTemplate(tempFileName, function(resultCode) {});
      });
    });
  });

  stackCommand = commander.command('stack [name] [template]');

  stackCommand.description('Create or update the named stack using the compiled template. Either an AWS_CLOUDFORMATION_HOME environment variable or a --cfn-home switch is required.');

  stackCommand.action(function() {
    var name, params, template;
    name = arguments[0], template = arguments[1], params = 3 <= arguments.length ? slice.call(arguments, 2) : [];
    validateArgs();
    return compileTemplate(template, params, function(compiled) {
      var tempFileName;
      tempFileName = generateTempFileName();
      return writeJsonTemplate(compiled, tempFileName, function() {
        process.stdout.write(coffinChar + " " + template + " -> ");
        return updateOrCreateStack(name, tempFileName, compiled, function(resultCode) {});
      });
    });
  });

  compileCommand = commander.command('compile [template]');

  compileCommand.description('Compile and write the template. The output file will have the same name as the coffin template plus a shiny new ".template" extension.');

  compileCommand.action(function() {
    var params, template;
    template = arguments[0], params = 2 <= arguments.length ? slice.call(arguments, 1) : [];
    validateArgs();
    return compileTemplate(template, params, function(compiled) {
      var fileName;
      process.stdout.write(coffinChar + " " + template + " -> ");
      fileName = generateOutputFileName(template, ".template");
      return writeJsonTemplate(compiled, fileName, function() {
        return process.stdout.write(fileName + "\n");
      });
    });
  });

  decompileCommand = commander.command('decompile [cfn-template]');

  decompileCommand.description('experimental - Convert the given cloud formation template to coffin (or as best as we can). It will output a file of the same name with ".coffin" extension.');

  decompileCommand.action(function(cfnTemplate) {
    validateArgs();
    return decompileCfnTemplate(cfnTemplate, function(decompiled) {
      var fileName;
      process.stdout.write(coffinChar + " " + cfnTemplate + " -> ");
      fileName = generateOutputFileName(cfnTemplate, ".coffin");
      return writeJsonTemplate(decompiled, fileName, function() {
        return process.stdout.write(fileName + "\n");
      });
    });
  });

  showHelp = function() {
    process.stdout.write(commander.helpInformation());
    return process.exit(1);
  };

  commander.command('').action(showHelp);

  commander.command('*').action(showHelp);

  if (process.argv.length <= 2) {
    showHelp();
  }

  module.exports.run = function() {
    return commander.parse(process.argv);
  };

}).call(this);
